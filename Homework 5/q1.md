#Homework 5

**Mathew Kurian (mk26473)**
**Kapil Gowru (krg766)**

-----
Question 1
-----
The Stack class has consensus number exactly two because:
- **Consensus Object**: The method T decide(T value) is called by each thread at most once. It is therefore *consistent* and *valid*.
- **Consensus Protocol**: A consensus solution that is both wait-free and lock-free.
- **Consensus Number**: A class C solves n-thread consensus if there exists a consensus protocol for any number of obejcts of class C and atomic registers. Therefore, a consensus number is the alrgest n for which class C solves n-thread consensus.

The protocol is wait-free since `decide()` contains no loops and `Stack` is inherently wait-free. There are two possible scenarios when a thread returns a value:
    1. Both threads return their own input meaning both must have popped `WIN`, violating the `Stack` protocol.
    2. Both threads return the other's input also violating the protocol.
In addition, the protocol states that at least one of the proposed values must be returned because its winning is value is written before `WIN` is popped.

```
class StackConsensus<T> {
    Stack s;
    T[] proposed;
    StackConsensus(){
        s.push(LOSE);
        s.push(WIN);
    }
    T decide(T value){
        proposed[threadID] = value;
        if (s.pop() == WIN){
            return proposed[threadID];
        } else {
            return proposed[1-threadID];
        }
    }
}
```
To prove that the `Stack` class has a consensus number of exactly two, we must first assume that we have a consensus protocol for threads A, B, and C. We continue to assume that A's next move takes the protocol to 0-valent state, and B's next move leads it to a 1-valent state. We know that these calls are non-commutative meaning that they are being called on teh same object. And since these calls cannot be made on registers, we have a consensus numver of 1. So now we have three cases: both A and B call `push()`, `pop()`, or A calls `push()` and B calls `pop()`.
    1. Both A and B call `pop()`: Let s' be the state if A pops, followed by B; and s" if the pops occur in reverse. S' is 0-valent while s" is 1-valent, so C cannot distinguish between both satates, and thus it is impossible for C to decide the correct value in both states.
    2. Both A and B call `push()`: Let s' be the state where A pushes a, and B pushes b, A pops b, B pops a. Let s" be the state after B pushes b, A pushes a, A pops a, and B pops b. The pops must occur because it is the only way to observe teh state of the stack. So s' and s" are indistinguishable for C, contradiction that s' is 0-valent while s" is 1-valent.
    3. A calls `push()` while B calls `pop()`: Let s' be the state after A pushes a, B pops a, and A pops the uppermost value of the stack (if it exists). Let s" be the state after B pops the uppermost value (if it exists), A pushes a, and A pops a. C cannot distinguish between both states. We do not care what happens if an empty stack is popped, since that does not affect the state visible to C.

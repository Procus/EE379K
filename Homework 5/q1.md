#Homework 5

**Mathew Kurian (mk26473)**
**Kapil Gowru (krg766)**

-----
Question 1
-----
The Stack class has consensus number exactly two because:
- **Consensus Object**: The method T decide(T value) is called by each thread at most once. It is therefore *consistent* and *valid*.
- **Consensus Protocol**: A consensus solution that is both wait-free and lock-free.
- **Consensus Number**: A class C solves n-thread consensus if there exists a consensus protocol for any number of obejcts of class C and atomic registers. Therefore, a consensus number is the alrgest n for which class C solves n-thread consensus.

The protocol is wait-free since `decide()` contains no loops and `Stack` is inherently wait-free. There are two possible scenarios when a thread returns a value:
    1. Both threads return their own input meaning both must have popped `WIN`, violating the `Stack` protocol.
    2. Both threads return the other's input also violating the protocol.
In addition, the protocol states that at least one of the proposed values must be returned because its winning is value is written before `WIN` is popped.

```
class StackConsensus {
    Stack s;
    int [] proposed;
    StackConsensus(){
        s.push(LOSE);
        s.push(WIN);
    }
    T decide(T value){
        proposed[threadID] = value;
        if (s.pop() == WIN){
            return proposed[threadID];
        } else {
            return proposed[1-threadID];
        }
    }
}
```
To prove that the `Stack` class has a consensus number of exactly two, we must first assume that we have a consensus protocol for threads A, B, and C. We continue to assume that A's next move takes the protocol to 0-valent state, and B's next move leads it to a 1-valent state. We know that these calls are non-commutative meaning that they are being called on teh same object. And since these calls cannot be made on registers, we have a consensus numver of 1. So now we have three cases: both A and B call `push()`, `pop()`, or A calls `push()` and B calls `pop()`.
    1. Both A and B call `pop()`: Let s' be the state if A pops, followed by B; and s" if the pops occur in reverse. In both these states, it is impossible for C to distinguish what values have been assigned to each thread.
    2. Both A and B call `push()`: Let s' be the state where A pushes a, and B pushes b, A pops b, B pops a. Let s" be the state after B pushes b, A pushes a, A pops a, and B pops b. In either case, the pops must occur because it is the only way to observe the state of the stack to each thread. However, for Thread C states s' and s" are indistinguishable and therefore cannot agree on a value.
    3. A calls `push()` while B calls `pop()`: Let s' be the state after A pushes a, B pops a, and A pops the uppermost value of the stack (if it exists). Let s" be the state after B pops the uppermost value (if it exists), A pushes a, and A pops a. In either case, A and B can identify which thread to agree upon. In the event a third thread C is added, that thread will not be able to identify the state of either A or B and will not know which thread to agree on. We do not care what happens if an empty stack is popped, since that does not affect the state visible to C.

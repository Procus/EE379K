
**Mathew Kurian (mk26473)**
**Kapil Gowru ()**

Homework 3
=====

#Question 1
To prove sequential consistency, we need to show that method calls appear to take effect in program order. In other words, we need to satify the logical sequence of program execution. For *Figure 3.13* and *Figure 3.14* we can arrange the methods so values are written and read with with accuracy as follows:

```
r.write(1) >> r.read(1) >> r.write(2) >> r.read(2)

```
If you look at the figures, it is clearly possible to interleave the code to do the aforementioned case thus it is sequentially consistent.

To prove linearizability, we must show sequential consistency and show that each operation appears to take effect atomically at some point between its invocation and completion. In other words, any read to a shared data item X returns the value stored by the most recent write operation on X. Upon analysis of the graph and taking into consideration the aforementioned sequential arrangement, we can see that both figures are also linearizable. 

#Question 2
This implementation is not linearizable. Let's say for example there are two threads. *Thread 1* calls `enq(1)` and it executes until it is about to set `item[0]` to `1` but it does not finish because `tail.compareAndSet(slot, slot+1)` will always be `false`. Meanwhile, *Thread 2* calls `enq(2)` and completes because `head.compareAndSet(slot, slot+1)` will return `true`. After that, Thread 2 will call `deq()` which will remove `item[0]` and throw an execption since value of `item[0]` has not been set. Therefore, this is not linearizable because Thread 2 enques, deques but then has an exception thrown when it should have retreived a value for `item[0]`.

#Question 3


#Question 4

##A.Graph

![enter image description here](http://i.imgur.com/q3zDOrj.jpg)